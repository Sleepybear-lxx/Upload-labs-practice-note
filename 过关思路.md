# 本项目记录自己代码审计upload-labs的过关思路。
文件上传过关的思路一定要确保两个原则
* 文件能正常上传（绕过前后端验证）
* 上传文件能被访问（文件路径可知）且按照脚本类型解析

通过源码查看，上传调试，确定哪些参数是自己可以控制的，进行上传绕过

# 常见函数
## isset(var) 
* 函数用于检测变量var是否已设置并且非 NULL。如果变量var存在且不为 NULL，则返回 TRUE，否则返回 FALSE.
## file_exists(path) 
* 函数检查path路径是否存在。如果存在则返回 TRUE，否则返回 FALSE
## move_uploaded_file(file,newloc) 
* 函数把上传的文件file移动到新位置newloc。如果成功该函数返回 TRUE，如果失败则返回 FALSE。
## trim(string)
* 函数移除字符串string两侧的空白字符
## deldot(string)
* 为common.php中自定义的函数，删除字符串string末尾的“.”，直到遇到第一个非“.”字符。
## strrchr(string,char) 
* 函数查找字符串char在另一个字符串string中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。
## strtolower(string)
* 将字符串string转换为小写。
## str_ireplace(find,replace,string)
* 将字符串string中的find字符替换为replace字符
## in_array(element,array)
* 函数搜索数组array中是否存在指定的值element。如果在数组中找到值则返回 TRUE，否则返回 FALSE
## strrpos(string,find) 
* 函数查找字符串find在另一字符串string中最后一次出现的位置（区分大小写）。
## substr(string,start) 
* 函数返回字符串的一部分。返回string字符串start下标开始的字符。



# 过关思路
## Pass-01
* 前端验证
前端js中验证文件后缀类型，绕过该验证即可。
拷贝源代码，本地搭建，删除js验证部分。
上传allow_ext变量允许的文件类型，burp抓包再修改为php文件。
## Pass-02
* 后端验证
如果$_FILES['upload_file']['type']满足要求即可上传，可通过抓包修改MIME类型进行绕过。

## Pass-03
* 黑名单验证
黑名单验证，因此需上传黑名单外的文件并成功解析。
上传jpg文件，上传.htaccess文件，配置jpg文件以php文件执行。（该关卡会将所有上传的文件重命名，htaccess文件上传后命名为“时间+随机数”.htaccess文件，该思路此处不可行）
上传phtml等其他文件，apache默认配置文件/etc/mime.types。后来在真实ubuntu中测试发现，即使没有开启phtml解析项，phtml也按照php来解析。目前原因未知。

## Pass-04
* 黑名单验证(相比于第三关，黑名单中增加大量后缀)，因此需上传黑名单外的文件并成功解析。
* 上传jpg文件，上传.htaccess文件，配置jpg文件以php文件执行。（该关卡未将上传的文件重命名）。

## Pass-05
* 待补充
## Pass-06
* 黑名单验证。
* 对比源码发现，该关卡删除了对于文件后缀名的大小写转换操作，构造不在黑名单中的脚本后缀，上传并成功解析。后来在真实ubuntu中测试发现，上传大写PHP后缀文件，可以正常访问，但无法解析，代码被当作注释未执行（解析为html）。目前原因未知。

## Pass-07
* 黑名单验证。
* 对比源码发现，该关卡删除了对于文件名两端的空格过滤操作，抓包修改文件名加上空格，成功上传，可以正常访问，但无法解析，代码被当作注释未执行（解析为html）。目前原因未知。

## Pass-08
* 黑名单验证。
* 对比源码发现，该关卡删除了对于文件名末尾“.”的过滤操作，抓包修改文件名加上“.”，上传并成功解析。后来在真实ubuntu中测试发现，上传“test.php.”文件，可以正常访问，但无法解析，代码被当作注释未执行（解析为html），目前原因未知。

## Pass-09(window系统特性)
* 黑名单验证。
* 对比源码发现，该关卡删除了对于文件名末尾“::$DATA”的过滤操作，抓包修改文件名加上“::$DATA”，上传并成功解析。

## Pass-10
* 黑名单验证。
* 分析deldot函数代码可知，该函数删除file name末尾的“.”，遇到非“.”字符停止。抓包修改文件名加上“. .”（点空格点），上传并成功解析（访问路径为文件名.php.%20）。

## Pass-11
* 黑名单验证。
* str_ireplace函数，只会顺序扫描（phpphp会被过滤），不会循环扫描（pphphp可以绕过）。抓包修改文件名后缀为pphphp，上传并成功解析。

## Pass-12
* 白名单验证。
* 只能上传jpg,png,gif后缀文件，关键是让服务器按照脚本类型解析。
查看源码发现save_path参数可控，在满足php版本小于5.3.4以及magic_quotes_gpc参数为OFF状态下，可以通过00截断漏洞完成解析。
抓包修改save_path参数为11.php%00，上传绕过。

## Pass-13
* 白名单验证。
* 同12关，只是后端采用$_POST变量接收数据，需要抓包修改为0x00解码后的字符，burp hex调整修改。

## Pass-14
* 白名单验证。
* 通过getReailFileType函数判断文件类型，可以构造图片马上传，后用文件包含漏洞解析。

## Pass-15
* 白名单验证。
* 通过isImage函数（调用getimagesize函数，该函数会自动判断是否为真实图片文件）判断文件类型，同14关。

## Pass-16
* 白名单验证。
* 通过isImage函数（调用exif_imagetype函数，该函数会自动判断是否为真实图片文件）判断文件类型，同14关。

## Pass-17
* 白名单验证。
* 查阅相关资料发现，该关卡重新渲染生成所上传的图片。下载图片马，打开发现，文件末尾的php代码被处理掉。需要对比上传的原始文件和服务器端生成的图片，在未进行改变的地方插入木马代码。上传，利用文件包含漏洞二次渲染后的图片。

但本关卡也调用了move_uploaded_file($tmpname,$target_path)函数，之后又重新生成图片。猜想此处也可通过二次竞争，生成webshell。

## Pass-18
* 白名单验证。
* 前端没有说明文件包含漏洞相关，若上传图片格式文件，无法解析，因此默认还需上传脚本文件。
本关卡先调用move_uploaded_file($tmpname,$target_path)函数上传文件，之后进行文件后缀名的验证。若后缀非图片类型，删除文件，否则重命名文件（图片类型后缀）。该方法逻辑上存在缺陷，当攻击者上传脚本文件后，立刻访问该脚本文件，服务端无法删除该文件，通过二次竞争方式绕过。
为了便于后续通过木马访问服务器，第一次上传文件内容非木马文件，而是需要在上传目录生成一个木马文件。在BUUCTF平台上因为访问次数过多，触发防火墙策略，本地Ubuntu环境成功上传并生成后门文件。

## Pass-19
* 白名单验证。
* php代码没有看明白，看了其他文章说同18关，二次竞争方式绕过，只不过上传图片马，利用文件包含或者解析漏洞去执行。待补充

## Pass-20
待补充

## Pass-21
待补充

# 参考链接：
* https://blog.csdn.net/weixin_47598409/article/details/115050869
* https://zhuanlan.zhihu.com/p/52099683



